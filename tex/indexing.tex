% Indexed table construction
\subsection{Индексирование}
Основной идеей ускорения поиска инструкции является индексирование - задание каждой инструкции уникального номера, по которому можно напрямую обратиться к инструкции. Например, можно поместить все инструкции в таблицу, вычислив для каждой уникальный индекс, и обращаться к полю таблицы по индексу, а не перебирая все поля таблицы. Основной проблемой является задание функции индекса. 

Поставим в соответствие каждой таблице некую битовую маску $table\_mask$ и будем говорить, что индекс инструкции это:

\begin{equation}
	index = instruction \& table\_mask
\end{equation}

В таком случае, необходима таблица размера $2^{S(table\_mask)}$.

Обозначим набор инструкций $S=\{I, M\}$. $I$- множество всех инструкций, $M$ - множество их масок.
\begin{eqnarray*}
	instr_i \subset I,\ \forall i,\ 0 \le i < |S|, \\
	mask_i \subset M,\ \forall i,\ 0 \le i < |S|
\end{eqnarray*}

Найдем маску (учитывая \ref{eq:bit_position}):

\begin{eqnarray} \label{eq:general_mask}
	general\_mask = OR_{j=0}^{|S|}mask_j\ \text{or}\nonumber \\
	Q_1(general\_mask)=\bigcup_{0}^{|S|}Q_1(mask_j)
\end{eqnarray}

Можно утверждать, что такая маска распознает все инструкции заданного набора, поскольку учитывает все значимые биты всех инструкций. И вообще для любого поднабора инструкций $S'$ верно, что $general\_mask$ этого поднабора распознает все его инструкции.

Рассмотрим построение таблицы для набора ARM. Был выделен набор наиболее частых инструкций, таб.\ref{tab:arm_top}. Построенная для него $general\_mask=0x0ff00070,\ S(general\_mask)=24$, значит требуется таблица размера $2^{24}$. Это неприемлемый размер для таблицы поиска, поэтому после анализа поднабора, было решено исключить из него инструкции lsl(0x0fe00070), cmp reg(0x0ff00010), rsb{0x0fe00010}. Таким образом, для нового набора $general\_mask=0x0ff00000, S(general\_mask)=8$. Требуемый размер таблицы - $2^8$.  

Индексирование всех инструкций в одну таблицу требует больших расходов по памяти, поэтому алгоритм гарантирует доступ по индексу только для популярных инструкций.

 \subsection{Коллизии}
 
 Рассмотрим процесс добавления инструкций в таблицу более подробно (рис. \ref{img:add_opcode}).
 
 \begin{figure}[h!] \label{img:add_opcode}
    \center{\includegraphics[width=0.9\linewidth]{add_opcode_sheme}}
    \caption{Процесс добавления инструкций в таблицу с маской 0x0ff00000}
    \label{img:add_opcode_sheme}
\end{figure}

Пусть, N - название инструкции, M - маска, I - опкод.

Имеется набор инструкций ARM: 

$S_{arm}=\{N, M, I\}$

И имеется поднабор популярных инструкций:

 $T_{arm}=\{N', M', I'\}$ (таб. \ref{tab:arm_top}).
 
Была построена маска (\ref{eq:general_mask}):

\begin{equation*}
	general\_mask=OR_{j=0}^{|T_{arm}|}mask_j^{T_{arm}} = 0x0ff00000
\end{equation*}

Инструкции $CMP,B \subset T_{arm}$, поэтому их индекс в поисковой таблице однозначно определен. A инструкции $ASR, ROR \not \subset T_{arm}$, поэтому не все их значащие биты были учтены при вычислении индекса. ASR/ROR неразличимы по $general\_mask$, для их распознавания необходимо рассмотреть биты <5,6>, иначе говоря нужна маска 0x00000060. Ситуацию, когда две или более инструкции имеют одинаковый индекс будем называть коллизией. 



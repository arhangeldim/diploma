% Indexed table construction
\subsection{Индексирование}
Основной идеей ускорения поиска инструкции является индексирование - задание каждой инструкции уникального номера, по которому можно напрямую обратиться к инструкции. Например, можно поместить все инструкции в таблицу, вычислив для каждой уникальный индекс, и обращаться к полю таблицы по индексу, а не перебирая все поля таблицы. Основной проблемой является задание функции индекса. 

Поставим в соответствие каждой таблице некую битовую маску $table\_mask$ и будем говорить, что индекс инструкции это:

\begin{equation}\label{eq:index}
	index = instruction\ \&\ table\_mask
\end{equation}

В таком случае, необходима таблица размера $2^{S(table\_mask)}$.

Обозначим набор инструкций $S=\{I, M\}$. $I$- множество всех инструкций, $M$ - множество их масок.
\begin{eqnarray*}
	instr_i \subset I,\ \forall i,\ 0 \le i < |S|, \\
	mask_i \subset M,\ \forall i,\ 0 \le i < |S|
\end{eqnarray*}

Найдем маску (учитывая \ref{eq:bit_position}):

\begin{eqnarray} \label{eq:general_mask}
	general\_mask = OR_{j=0}^{|S|}mask_j\ \text{, or}\nonumber \\
	Q_1(general\_mask)=\bigcup_{0}^{|S|}Q_1(mask_j)
\end{eqnarray}

Можно утверждать, что такая маска распознает все инструкции заданного набора, поскольку учитывает все значимые биты всех инструкций. И вообще для любого поднабора инструкций $S'$ верно, что $general\_mask$ этого поднабора распознает все его инструкции.

Рассмотрим построение таблицы для набора ARM. Был выделен набор наиболее частых инструкций, таб.\ref{tab:arm_top}. Построенная для него $general\_mask=0x0ff00070$, $S(general\_mask)=24$, значит требуется таблица размера $2^{24}$. Это неприемлемый размер для таблицы поиска, поэтому после анализа поднабора, было решено исключить из него инструкции lsl(0x0fe00070), cmp reg(0x0ff00010), rsb{0x0fe00010}. Таким образом, для нового набора $general\_mask=0x0ff00000, S(general\_mask)=8$. Требуемый размер таблицы - $2^8$. Нужно заметить, что при таком алгоритме построения, маскимальная глубина вложенности таблиц равна 3. Максимальный размер таблицы - $2^8$. 

Индексирование всех инструкций в одну таблицу требует больших расходов по памяти, поэтому алгоритм гарантирует доступ по индексу только для популярных инструкций.

 \subsection{Коллизии}
 
 Рассмотрим процесс добавления инструкций в таблицу более подробно (рис. \ref{img:add_opcode_sheme}).
 
 \begin{figure}[h!] \label{img:add_opcode}
    \center{\includegraphics[width=0.9\linewidth]{add_opcode_sheme}}
    \caption{Процесс добавления инструкций в таблицу с маской 0x0ff00000}
    \label{img:add_opcode_sheme}
\end{figure}

Пусть, N - название инструкции, M - маска, I - опкод.

Имеется набор инструкций ARM: 

$S_{arm}=\{N, M, I\}$

И имеется поднабор популярных инструкций:

 $T_{arm}=\{N', M', I'\}$ (таб. \ref{tab:arm_top}).
 
Была построена маска (\ref{eq:general_mask}):

\begin{equation*}
	general\_mask=OR_{j=0}^{|T_{arm}|}mask_j^{T_{arm}} = 0x0ff00000
\end{equation*}

Инструкции $CMP,B \subset T_{arm}$, поэтому их индекс в поисковой таблице однозначно определен. A инструкции $ASR, ROR \not \subset T_{arm}$, поэтому не все их значащие биты были учтены при вычислении индекса. ASR/ROR неразличимы по $general\_mask$, для их распознавания необходимо рассмотреть биты <5,6>, иначе говоря нужна маска 0x00000060. Ситуацию, когда две или более инструкции имеют одинаковый индекс будем называть коллизией. 

Коллизии возникают вследствие того, что в таблицу добавляются инструкции, маски которых не учтены при построении маски таблицы. Предлагается вычислять маску для конфликтующих инструкций, создавать подтаблицу и индексировать инструкции в нее. В каждой записи таблицы верхнего уровня следует хранить метку, о типе записи - инструкция или подтаблица.

При построении маски таблицы (\ref{eq:general_mask}) возникает и другая проблема. Предположим, существуют две инструкции: 

\begin{align*}
		& instr_1 = 0x03a00000,\ mask_1=0x0fe00000 \\
		& instr_2 = 0x03500000,\ mask_2=0x0ff00000 \\
		& general\_mask = 0x0fe00000\ |\ 0x0f100000 = 0x0ff00000
\end{align*}


Маска для таблицы вычисляется как показано выше. Таким образом, помимо значащих битов, маска проверяет незначимые биты опкода, что должно быть учтено при построении таблицы. Например, есть входные битовые строки $s_1 = 0xe3b05070,\ s_2=0xe3a05070$. Обе строки представляют собой закодированную инструкцию $instr_1$ и это можно проверить, применив маску $mask_1$. Но если посчитать индексы этих строк в таблице с маской $general\_mask$, то они будут различаться.

\begin{align*}
	& s_1\ \&\ mask_1 = instr_1 \\
	& s_2\ \&\ mask_1 = instr_1 \\
	& index_{s_1} = s_1\ \&\ general\_mask = 0x03a00000 \\
	& index_{s_2} = s_2\ \&\ general\_mask = 0x03b00000
\end{align*}

Чтобы определить, какие индексы должны быть у одной инструкции в таблице, вычислим разницу масок (\ref{eq:diff}):

\begin{equation}\label{eq:diff}
	diff = (mask\ \&\ table\_mask)\ \oplus table\_mask
\end{equation}

Операция \& нужна, чтобы при вычислении разницы использовать биты, учтенные конкретной маской таблицы. После получения diff, можно генерировать набор записей для инструкции, всего для каждой таблицы требуется создать $n = 2^{Q_1(diff)}$ дублирующих записей. Записи создаются во время инициализации таблицы и требуют дополнительной памяти. Вариант с использованием масок типа $AND_{j=0}^{N}mask_j$ не требует дублирующих записей, но приводит к созданию многих вложенных таблиц из-за большого числа коллизий.

Сведем все шаги алгоритма воедино:

\begin{enumerate}
	\item Отсортировать набор инструкций по весу и выбрать поднабор наиболее частых инструкций. В данной работе поднабор определен как множество инструкций, занимающих 80\% исполняемого кода (рис. \ref{img:stat_arm_percent});
	\item Построить $general\_mask$ (\ref{eq:general_mask}) и создать таблицу размера $2^{S_1(general\_mask)}$;
	\item Проиндексировать инструкции и поместить их в таблицу (в случае необходимости вычислить (\ref{eq:diff}) и сгенерировать дополнительные записи);
	\item В случае коллизии создать подтаблицу и заново проиндексировать инструкции;
\end{enumerate}

Тогда для определения инструкции необходимо будет:

\begin{enumerate}
	\item Вычислить индекс в таблице верхнего уровня (\ref{eq:index});
	\item Определить тип записи. Если тип "INSTRUCTION\", то декодирование завершено, если тип "SUBTABLE\", то требуется вычислить индекс в подтаблице;
	\item Если тип записи "NONE\", то такой инструкции не существует. 
\end{enumerate}

Это означает, что декодирование будет требовать минимум процессорных операций. Вычисление индекса - операция логического "И\", проверка типа записи, если имеет место коллизия, то переход в подтаблицу. Максимальная глубина подтаблицы равна 3, соответственно это максимальное количество итераций поиска инструкции. Поиск не зависит от количества инструкций в наборе, так как не использует перебор. Сложность алгоритма O(1) - глубина дерева поиска зависит от комбинаций битов в масках инструкций, но не от количества входных данных, инструкций набора.




%Popek and Goldberg formal virtualization requirements

Первое описание формальных требований, которым должна удовлетворять архитектура для поддержки ее виртуализации, было опубликовано в 1974 в статье Gerald J. Popek and Robert P. Goldberg "Formal Requirements for Virtualizable Third Generation Architectures" \cite{bib:popek_goldberg}.

Монитор виртуальных машин (монитор, гипервизор) - программа, позволяющая запустить несколько операционных систем на одном хостовом компьютере. Монитор должен обладать следующими свойствами:

\begin{itemize}
    \item идентичность, эквивалентность - программа, запущенная под управлением монитора, должна вести себя идентично программе, запущенной на реальном оборудовании;
    \item управление ресурсами - монитор полностью контролирует свои ресурсы;
    \item производительность - значительная часть гостевых инструкций должна выполняться без вмешательства монитора;
\end{itemize}

Также описываются требования к набору инструкций, которым должна удовлетворять архитектура. Инструкции делятся на три группы:

\begin{enumerate}
    \item privileged - выполняются в привилегированном режиме;
    \item control sensitive - могут изменить режим или состояние процессора;
    \item behavior sensitive - поведение инструкции зависит от состояния процессора;
\end{enumerate}

\textbf{Теорема: } если sensitive инструкции являются подмножеством priveleged инструкций, то архитектура виртуализуема.

Это означает, что при обработке sensitive инструкций управление может быть передано монитору. Непривилегированные инструкции могут исполняться нативно. Такая техника называется trap-and-emulate virtualization или классическая виртуализация. Архитектура ARM не является виртуализуемой, так как часть sensitive инструкций не является priveleged.

Для более формального определения инструкции, нужно ввести понятие модели процессора. Пусть процессор может работать в одном из двух режимов - supervisor и user. В режиме supervisor ему доступен весь набор инструкций, в режиме user нет. Процессор может также находиться в одном из конечного множества состояний. Каждое состояние S определяется четырьмя компонентами\cite{bib:popek_goldberg}: состояние памяти \textit{E}, режим процессора \textit{M}, указатель инструкций \textit{P}, регистр смещения адреса \textit{R}.

\begin{equation}\label{eq:machine_state}
    S=\left<E, M, P, R\right>
\end{equation}

$E[i]$ - означает $i$-й элемент памяти. Причем, для $E$ размера $q$: $E=E' \Leftrightarrow E[i] = E'[i]$, для любого $0 \le i  \le q$. $R=(l, b)$ состоит из двух частей, $l$ - база, $b$ - лимит. Обозначим конечное множество состояний как $C$, тогда инструкция может быть определена как функция из $C$ в $C$, т.е.  $i:C\to C$. Например, $i(S_1) = S_2,\ i(E_1, M_1, P_1, R_1) = (E_2, M_2, P_2, R_2)$. Для определения привилегированных инструкций потребуется понятие исключения (\textit{trap}).

\textbf{Определение}: инструкция вызывает исключение (\textit{trap}), если $i(S_1) = S_2,\ i(E_1, M_1, P_1, R_1) = (E_2, M_2, P_2, R_2)$, где

\begin{equation*}
    \begin{aligned}
        &E_2[j] = E_1[j],\ 0 \le j \le q,\\
        &E_2[0] = (M_1, P_1, R_1),\\
        &(M_2, P_2, R_2) = E_1[1].
    \end{aligned}
\end{equation*}

Таким образом, исключение сохраняет текущий контекст и передает управление специальной процедуре, изменяя внутренне состояние процессора $(M, P, R)$.

\textbf{Определение}: инструкция называется привилегированной (privileged) тогда и только тогда, когда для любой пары состояний $S_1=\left<e, s, p, r\right>$ и $S_2=\left<e, u, p, r\right>$ $i(S_2)$ вызывает исключение(\textit{trap}), а $i(S_1)$ - нет. Состояния $S_1, S_2$ различаются лишь режимом процессора: $S_1 - supervisor, S_2 - user$.

Другая важная группа инструкций - sensitive инструкции.

\textbf{Определение}: инструкция $i$ является \textit{control sensitive}, если существует состояние $S_1=\left<e_1, m_1, p_1, r_1\right>$, и $i(S_1) = S_2 = \left<e_2, m_2, p_2, r_2\right>$ такая, что $a)\ r1 \ne r2$, или $b)\ m_1 \ne m_2$, или $a),\ b)$ совместно.

Также определим для любого целого $x$ операцию $\otimes$ : $r' = r \otimes x = (l+x, b)$. $R=(l, b)$ - определяет, к каким адресам памяти можно обращаться из состояния $R$. Таким образом $E|r \otimes x$ обозначает, что доступны адреса с $|l + x|$ по $|l + x + b|$. Теперь можно ввести новый класс инструкций.

\textbf{Определение}: Инструкция $i$ является \textit{behavior sensitive}, если существует целое $x$ и состояния:

\begin{equation*}
    \begin{aligned}
        &S_1=\left<e | r, m_1, p, r\right>, \\
        &S_2=\left<e | r, m_2, p, r\right>,
    \end{aligned}
\end{equation*}

где

\begin{equation*}
    \begin{aligned}
        &i(S_1) = \left<e_1 | r, M_1, P_1, r\right>, \\
        &i(S_2) = \left<e_2 | r \otimes x, m_2, p_2, r \otimes x\right>,
    \end{aligned}
\end{equation*}

удовлетворяют условиям

\begin{equation*}
    \begin{aligned}
        &e_1 | r \ne e_2 | r \otimes x, или \\
        &p_1 \ne p_2, или \\
        &оба совместно
    \end{aligned}
\end{equation*}


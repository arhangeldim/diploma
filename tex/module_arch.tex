%programm arch
\subsection{Архитектура модуля}
Далее будет приведена архитектура программного модуля, реализующего описанный выше алгоритм. Модуль реализован с использованием языка С, и ассемблера ARM. Основной абстракцией, использующейся в алгоритме, является инструкция. Она представлена в виде структуры:

\scriptsize
\begin{verbatim}
    typedef struct opcode {
        uint32_t mask;
        uint32_t value;
        uint32_t nmask;
        uint32_t nvalue;
        uint16_t weight;
        const char *info;
    } opcode_t;
\end{verbatim}
\normalsize

Видно, что помимо полей, описанных в алгоритме выше (маска, value/значение, вес), используются поля nmask, nvalue. Эти поля нужны для обработки специальных случаев, когда документация описывает некоторые биты в виде отрицания, например, для инструкции strb(arm) на позициях <26-20> разрешены любые комбинации битов, кроме <1000111>. Такая проверка применяется при добавлении в таблицы сгенерированных дублирующих инструкций на стадии индексирования. Строка info содержит произвольную текстовую информацию об инструкции(например, имя). Все опкоды хранятся в массиве, информация о полях вязта из спецификации и из предварительного исследования (веса).

Таблица поиска имеет следующую структуру:

\scriptsize
\begin{verbatim}
    typedef struct table {
        uint8_t level;
        uint8_t shift;
        uint32_t mask;
        uint8_t size;
        item_t *items;
    } table_t;
\end{verbatim}
\normalsize

Поле level хранит глубину вложенности таблицы в дереве поиска, поле shift используется для оптимизации и равняется $min(Q_1(table\_mask))$. Размер таблицы хранится в поле size, items - указатель на массив элементов размера size. Элементы таблицы представлены в виде структуры:

\scriptsize
\begin{verbatim}
    typedef struct item {
        item_type_t utype;
        union {
            const struct   opcode *op;
            struct table   *tab;
        } u;
    } item_t;
\end{verbatim}
\normalsize
    
В каждой записи таблицы хранится ее тип - подтаблица или инструкция - и ссылка на соответствующий объект. Объект записи является закрытым извне и не принадлежит интерфейсу, здесь приведен только для пояснения алгоритма.

Интерфейс к модулю выглядит следующим образом:

\scriptsize
\begin{verbatim}
    void create_indexed_table(const opcode_t *opcode_table, table_t **indexed_table, int thr);
    void destroy_table(table_t *tab);
    void decode(table_t *indexed_table, uint32_t input_value, const opcode_t **op);
\end{verbatim}
\normalsize


При создании индексированной таблицы можно задать пороговое значение, какую часть инструкций нужно обрабатывать с оптимизацией. По умолчанию стоит значение 80\%. Функция занимается построением таблицы, все вспомогательные функции (генерация масок, дублирующих записей, разрешение коллизий) скрыты за интерфейсом. Архитектура позволяет использовать различные наборы инструкций и задавать порог. Так для модуля написаны наборы ARM, Thumb, Thumb2, VFP/SIMD. Для наборов собрана статистика и веса заданы в соответствии с полученной информацией. Для платформы ARM был написан специальный код, использующий платформозависимые функции для оптимизации декодирования инструкций. Это небольшая функция, подключаемая при исполнении на ARM.


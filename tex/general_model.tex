% Общая модель
Декодирование инструкций состоит из нескольких этапов. Во-первых, это выделение опкода (закодированная инструкция и ее аргументы и флаги) из исходного машинного кода. Этот этап достаточно простой, так как ARM - это RISC архитектура и опкоды имеют фиксированный размер 16, 32 бита. Затем нужно сопоставить опкод одной из инструкций набора или проверить, что такой инструкции не существует.

Существует несколько основных групп инструкций: арифметические и логические операции, работа с памятью, условные и безусловные переходы, работа с системными регистрами и регистрами сопроцессора. В каждом валидном опкоде закодирована сама инструкций (например, add, сложение), ее операнды, условия, при которых она должна быть выполнена и дополнительные флаги, меняющие поведение инструкции.  После определения инструкции нужно разобрать ее операнды, условия и флаги и выполнить ее эмуляцию (трансляцию). Формат опкода и метод поиска соответствующей инструкции будут рассмотрены ниже.

Если провести анализ кода, то можно заметить, что одни инструкции набора исполняются часто, другие редко, а некоторые вообще не вызываются ни разу. Таким образом, можно выделить поднабор инструкций, которые имеют высокую частоту вхождения в код. Время исполнения инструкций такого поднабора оказывает  значительное влияние на время работы программы в целом.

В этот поднабор входят арифметические и логические операции, сохранение и загрузка из памяти, операции переходов - это соответствует специфике архитектуры ARM(load/store architecture). Все операции с данными исполняются в регистрах, поэтому данные надо постоянно загружать из памяти и сохранять их обратно.

На основе данных о частоте вхождения инструкции в код, можно для каждой инструкции задать характеристику - вес. Чем чаще исполняется инструкция, тем больше ее вес, и тем больше время исполнения конкретной инструкции влияет на производительность в целом.

Статистику по инструкциям можно собирать на различных рабочих наборах, задачах. В данной работе используется статистика, собранная в ходе загрузки ядра Linux. Это связано с задачами для эмулятора в целом, требовалось поддержать загрузку ядра и основных служб операционной системы. Также на начальном этапе собиралась статическая информация об инструкциях. Для этого анализировался исходный код некоторых простых утилит. Такой подход не дает возможности оптимального декодирования на всех задачах, однако по большей части список наиболее популярных инструкций на различных задачах совпадает. В дальнейшем будем придерживаться допущения, что статистика верна для любой задачи. Ниже будут подробнее рассмотрены методы сбора информации о частоте инструкций и подходы к составлению списка популярных инструкций.

Также, после сбора информации, требуется определить, декодирование каких инструкций стоит оптимизировать и как их обработка может быть встроена в общий алгоритм. В дальнейшем будет показано, что около 80\% времени происходит обработка небольшого набора инструкций (около 10 инструкций), и, если сконцентрироваться на обработке именно этих популярных инструкций, можно получить преимущество во времени декодирования в целом.  